# Cursor Rules for Turborepo React/React Native Monorepo

## Package Management - CRITICAL
- React version is LOCKED at 19.1.1 - NEVER change
- React DOM version is LOCKED at 19.1.1 - NEVER change
- NEVER edit package.json dependencies manually
- ALWAYS use CLI commands for package installation
- Check existing versions before adding new packages: `pnpm list package-name`
- Use exact versions, no ^ or ~ for React ecosystem packages

## Installation Commands
```bash
# Web app packages
cd apps/web && pnpm add package@exact-version

# Mobile app packages  
cd apps/mobile && npx expo install package@exact-version

# Shared packages
cd packages/utils && pnpm add package@exact-version

# Root workspace packages
pnpm add -w package@exact-version
```

## React/React Native Best Practices
- Use functional components with hooks only
- Implement TypeScript for all components
- Create reusable components in packages/ui
- Use React.memo, useMemo, useCallback for performance
- Follow single responsibility principle

## Architecture Rules
- Shared code goes in packages/ directory
- Use @repo/package-name convention
- Never import between apps directly
- Keep platform-specific code in respective apps
- Use absolute imports with path mapping

## PARALLEL DEVELOPMENT - MANDATORY
- ALL features MUST be implemented for BOTH web and mobile simultaneously
- NEVER develop features for only one platform
- ALWAYS create shared components in packages/ui first
- ALWAYS implement business logic in packages/utils
- ALWAYS test on both platforms before committing
- Both apps must build successfully together

## File Naming
- Components: PascalCase (UserProfile.tsx)
- Hooks: camelCase with 'use' prefix (useUserData.ts)
- Utils: camelCase (formatDate.ts)
- Constants: UPPER_SNAKE_CASE (API_ENDPOINTS.ts)

## Performance Guidelines
- Lazy load components with React.lazy
- Use Suspense for loading states
- Implement proper error boundaries
- Optimize bundle size with tree shaking
- Use React DevTools Profiler for optimization

## Code Quality
- Write unit tests for shared packages
- Use ESLint and Prettier configurations
- Follow consistent import ordering
- Document complex business logic
- Use meaningful variable and function names

## Forbidden Actions
- Modifying React/React DOM versions
- Direct package.json editing
- Cross-app imports
- Prop drilling (use context instead)
- Inline styles (use styled-components or CSS modules)
- Any package installation without version checking
- Single-platform feature development
- Committing code that breaks either web or mobile
- Implementing features without shared components

## State Management
- Use a centralized state management library for global state (e.g., Zustand, Redux)
- Use React Query/TanStack Query for managing server state, caching, and background refetching
- Do NOT use `useState` for data that needs to be shared across multiple components
- Always define clear actions/reducers for state modifications

## Type Safety
- AVOID using `any` type. Define specific types or interfaces for all data structures
- Use TypeScript generics for creating reusable and type-safe components and functions
- All function parameters and return values must have explicit types
- Use `zod` for runtime validation of API responses and forms to ensure type safety

## Turborepo Workflow
- `pnpm dev` - Start all apps in parallel
- `pnpm build` - Build all apps and packages
- `pnpm lint` - Run linting across workspace
- `pnpm test` - Run tests across workspace
- Build tasks depend on shared packages building first
- Test tasks can run independently
- Lint tasks should run before build in CI
- Enable remote caching for CI/CD
- Cache build outputs in dist/ and build/ directories
- Add new apps to apps/ directory
- Add new packages to packages/ directory
- Update turbo.json when adding new tasks
- Maintain consistent scripts across packages
- Use turbo run build --filter=[CHANGED] in CI/CD
- **MANDATORY**: Both web and mobile must build successfully before any deployment
- **MANDATORY**: Features must be tested on both platforms before merge
- Deploy both platforms together to maintain feature parity

## UI/UX Design Rules — Paddle Training App (Web & Mobile)

- Visual Direction
  - Sporty, energetic, optimistic. Use brand tokens from `packages/ui/tamagui.config.ts`.
  - Primary actions use `color.primary` with `primaryContrast` text. Reserve `accent` for highlights and promotions.
  - Backgrounds: `bgSoft` for app surfaces, `surface` for cards and interactive containers.

- Layout & Spacing
  - Use an 8px spacing scale (tokens radius 1–5 already aligned). Minimum touch target: 44×44 px.
  - Content max-width on web: 1200px. Use responsive containers; avoid full-width long measure text.
  - Group related controls within `BrandCard` sections; avoid dense, ungrouped lists.

- Typography
  - Use `SafeText` and shared typography styles from `@repo/ui`. Maintain 1.4–1.6 line-height for body text.
  - Titles: concise, action-oriented (e.g., “Book a Session”). Avoid all caps; prefer Title Case.

- Components & Patterns
  - Always prefer shared components in `@repo/ui` (`BrandButton`, `TextField`, `BrandCard`, `ErrorFallback`). Add new primitives there first.
  - Forms use `react-hook-form` with `TextField`. Show inline field errors and a toast via notify on submit errors.
  - Buttons: one primary per view; secondary/tertiary for less-critical actions. Destructive actions use confirm flows.

- Navigation
  - Web: use `react-router-dom`. Keep top-level routes shallow and descriptive: `/sessions`, `/trainers`, `/courts`, `/book`, `/profile`.
  - Mobile: bottom tabs for primary sections; stack for details. Avoid more than 2 nested levels.
  - Preserve scroll/position on route changes; deep links must resolve to the correct detail view.

- States (Loading/Empty/Error/Success)
  - Loading: skeletons for lists and buttons’ built-in loading states; no spinner-only screens.
  - Empty states: friendly copy + primary CTA (e.g., “No sessions yet. Explore sessions”).
  - Errors: rely on Error Boundaries for unexpected; for recoverable, show inline message + `notify.error(...)`.
  - Success: show concise confirmation with next-step CTA and `notify.success(...)`.

- Accessibility
  - Maintain 4.5:1 contrast for text; ensure focus outlines are visible. Provide text alternatives for icons.
  - Support keyboard navigation on web; ensure tab order follows DOM order. Don’t block pinch-zoom.

- Motion & Feedback
  - Use subtle 150–250ms transitions; keep motion purposeful (state change, navigation). Avoid parallax/overuse.
  - Provide immediate feedback on interactions: button loading, optimistic UI where safe.

- Copy & Tone
  - Friendly, concise, motivational. Avoid jargon. Examples: “Let’s play!”, “Great choice!”, “You’re all set”.
  - Avoid technical error details; map to user-friendly language per apps/.cursorrules Error Handling Policy.

- Domain-specific Patterns
  - Session Discovery: persistent filters (area, date, rank, price), infinite list with `react-virtual` on web.
  - Booking Flow: 4 clear steps — Pick session → Choose court/time → Confirm participants & price → Pay.
  - Trainer Profiles: show rank, price/hour, coverage areas, ratings, availability; primary CTA: “Request Trainer”.
  - Court Selection: map/list toggle; show distance, availability slots; confirm with summary.
  - Payments: show fees and totals clearly; support card and cash-like flows; handle 3DS/retries gracefully.
  - Ratings: 1–5 with short tags; nudge after sessions with a non-blocking prompt.

- Error Handling Alignment
  - Use `apps/web/src/lib/notify.ts` and `apps/mobile/src/lib/notify.ts`. Never expose raw server errors.
  - For queries/mutations: `useErrorBoundary: (e) => (e as any)?.status >= 500`; `onError: (e) => notify.error(parseMessage(e))`.

- Responsiveness
  - Design mobile-first; ensure breakpoints support small tablets. Avoid horizontal scrolling.
  - Use Flex layouts compatible with `react-native-web` in shared UI.

- Design Review Checklist (Per Screen)
  - Clear primary CTA, minimal cognitive load, correct tokens, accessible contrast.
  - Proper loading/empty/error states wired, graceful auth-expired handling.
  - Keyboard/gesture friendliness, performance on low-end devices, parity across web/mobile.

- Do / Don’t
  - DO build new UI primitives in `@repo/ui` first. DON’T duplicate styles in apps.
  - DO keep copy short and encouraging. DON’T use technical or negative language.
  - DO use skeletons and optimistic updates. DON’T block UI without feedback.

Reference: full guidelines in `packages/ui/UX_GUIDELINES.md` and checklists in `packages/ui/UX_CHECKLISTS.md`.

## Styling Policy - MANDATORY

**NEVER use Tailwind CSS or any other CSS framework. Use ONLY Tamagui.**

- UI Library: Tamagui ONLY
  - ALL styling must use Tamagui components and tokens from `@repo/ui`
  - Use `tamagui.config.ts` tokens for colors, spacing, typography, and shadows
  - NEVER import or use Tailwind CSS classes, utilities, or configuration
  - NEVER add `tailwindcss` to any package.json

- Styling Rules
  - Use Tamagui styled components: `styled(View, { ... })`
  - Use Tamagui tokens: `$color.primary`, `$space.4`, `$fontSize.lg`
  - For custom styles, extend Tamagui themes in `packages/ui/tamagui.config.ts`
  - Use Tamagui responsive props: `width={{ xs: 100, md: 200 }}`

- Forbidden Styling
  - NEVER use `className` with Tailwind classes
  - NEVER use CSS-in-JS libraries other than Tamagui
  - NEVER use inline styles that bypass Tamagui tokens
  - NEVER install or configure Tailwind CSS, PostCSS, or similar

- Component Creation
  - Build all UI components in `packages/ui` using Tamagui
  - Export styled components from `@repo/ui`
  - Use Tamagui's `createTamagui` for theme configuration
  - Leverage Tamagui's built-in responsive and theme system