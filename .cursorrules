# Cursor Rules for Turborepo React/React Native Monorepo

## Package Management - CRITICAL
- React version is LOCKED at 19.1.1 - NEVER change
- React DOM version is LOCKED at 19.1.1 - NEVER change
- NEVER edit package.json dependencies manually
- ALWAYS use CLI commands for package installation
- Check existing versions before adding new packages: `pnpm list package-name`
- Use exact versions, no ^ or ~ for React ecosystem packages

## Installation Commands
```bash
# Web app packages
cd apps/web && pnpm add package@exact-version

# Mobile app packages  
cd apps/mobile && npx expo install package@exact-version

# Shared packages
cd packages/utils && pnpm add package@exact-version

# Root workspace packages
pnpm add -w package@exact-version
```

## React/React Native Best Practices
- Use functional components with hooks only
- Implement TypeScript for all components
- Create reusable components in packages/ui
- Use React.memo, useMemo, useCallback for performance
- Follow single responsibility principle

## Architecture Rules
- Shared code goes in packages/ directory
- Use @repo/package-name convention
- Never import between apps directly
- Keep platform-specific code in respective apps
- Use absolute imports with path mapping

## PARALLEL DEVELOPMENT - MANDATORY
- ALL features MUST be implemented for BOTH web and mobile simultaneously
- NEVER develop features for only one platform
- ALWAYS create shared components in packages/ui first
- ALWAYS implement business logic in packages/utils
- ALWAYS test on both platforms before committing
- Both apps must build successfully together

## File Naming
- Components: PascalCase (UserProfile.tsx)
- Hooks: camelCase with 'use' prefix (useUserData.ts)
- Utils: camelCase (formatDate.ts)
- Constants: UPPER_SNAKE_CASE (API_ENDPOINTS.ts)

## Performance Guidelines
- Lazy load components with React.lazy
- Use Suspense for loading states
- Implement proper error boundaries
- Optimize bundle size with tree shaking
- Use React DevTools Profiler for optimization

## Code Quality
- Write unit tests for shared packages
- Use ESLint and Prettier configurations
- Follow consistent import ordering
- Document complex business logic
- Use meaningful variable and function names

## Forbidden Actions
- Modifying React/React DOM versions
- Direct package.json editing
- Cross-app imports
- Prop drilling (use context instead)
- Inline styles (use styled-components or CSS modules)
- Any package installation without version checking
- Single-platform feature development
- Committing code that breaks either web or mobile
- Implementing features without shared components

## State Management
- Use a centralized state management library for global state (e.g., Zustand, Redux)
- Use React Query/TanStack Query for managing server state, caching, and background refetching
- Do NOT use `useState` for data that needs to be shared across multiple components
- Always define clear actions/reducers for state modifications

## Type Safety
- AVOID using `any` type. Define specific types or interfaces for all data structures
- Use TypeScript generics for creating reusable and type-safe components and functions
- All function parameters and return values must have explicit types
- Use `zod` for runtime validation of API responses and forms to ensure type safety

## Turborepo Workflow
- `pnpm dev` - Start all apps in parallel
- `pnpm build` - Build all apps and packages
- `pnpm lint` - Run linting across workspace
- `pnpm test` - Run tests across workspace
- Build tasks depend on shared packages building first
- Test tasks can run independently
- Lint tasks should run before build in CI
- Enable remote caching for CI/CD
- Cache build outputs in dist/ and build/ directories
- Add new apps to apps/ directory
- Add new packages to packages/ directory
- Update turbo.json when adding new tasks
- Maintain consistent scripts across packages
- Use turbo run build --filter=[CHANGED] in CI/CD
- **MANDATORY**: Both web and mobile must build successfully before any deployment
- **MANDATORY**: Features must be tested on both platforms before merge
- Deploy both platforms together to maintain feature parity